# 原子操作

原子操作是C++内存模型的基础。默认情况下，强内存模型支持原子操作；因此，理解强内存模型的特征很有意义。

##强/弱内存模型

您可能已经从编程协议的小节中了解到：强内存模型中的是顺序一致性，在弱内存模型中的松散语义。

###强内存模型

2004年Java 5.0有了内存模型，2011年C++添加了内存模型。在此之前，Java有一个错误的内存模型，而C++则没有内存模型。多线程编程已经有40~50年的历史了。在1979年，[Leslie Lamport](https://en.wikipedia.org/wiki/Leslie_Lamport) 就定义了顺序一致性的概念。

顺序一致性提供了两个保证:

* 指令按源码顺序执行。
*  线程上的所有操作都遵循一个全局顺序。

在深入研究这两个保证之前，我想强调一下，这些声明只适用于原子操作，但影响并不止于原子操作。

下面图形显示了两个线程。每个线程分别将值存储到变量x或y中，加载另一个变量y或x，并将它们存储在变量res1或res2中。

![](../../../images/detail/memory-model/3.png)

> 两个原子操作

通常，原子操作保证顺序一致性。问题是：这些语句以什么顺序执行?

顺序一致性的第一个保证是，指令按照源代码中定义的顺序执行。这很容易，任何存储操作都无法在加载操作之前进行。

顺序一致性的第二个保证是，所有线程的所有指令必须遵循全局顺序。上图中的情况，意味着线程2看到线程1的操作的顺序与线程1执行它们的顺序相同，这很关键。线程2按照线程1的源代码顺序查看线程1的所有操作，从线程1的角度来看也是如此。你可以将这个特性，想象成一个所有线程都必须遵守的全局时钟。全局时钟就是全局顺序。时钟每发出一次滴答声，就会发生一个原子操作，但你永远不知道是哪个。

我们的谜题还没有解开。我们仍然需要观察，这两个线程交错的执行方式。因此，这两个线程有以下六种交运行方式。

![](../../../images/detail/memory-model/4.png)

> 两条线的六个交错执行可能

很简单，对吧？这就是顺序一致性，也称为**强内存模型**。

### 弱内存模型

我们再参考一下程序开发者和系统之间的“协议”。

这个特殊的例子中，程序开发者使用了原子操作(开发者遵循协议的相应部分)。系统保证程序的行为，从而不会存在数据竞争。另外，系统可以在每个组合中执行四个操作。如果程序开发者使用松散语义，协议的基础部分就会发生巨大的变化。一方面，程序开发者可能很难理解两个线程之间的交错。另一方面，系统有了更多优化的空间。

使用松散语义(也称为弱内存模型)，可使这四种操作有更多的组合。有种很难理解的行为是，线程1可以以不同的顺序查看线程2的操作，这样全局时序图就不存在了。从线程1的角度来看，操作`res2= x.load()`可能在`y.store(1)`之前执行。甚至是，线程1或线程2没有按照源代码中的顺序执行。例如，线程2可以先执行`res2= x.load()`，再执行`y.store(1)`。

“序列一致性”和“松散语义”之间还有一些模型，其中最重要的是“获取-释放”语义。“获取-释放”语义中，程序开发人员需要遵守比“顺序一致性”更弱的规则。相较之下，系统有更多优化的空间。因为线程是在特定同步点上进行同步，所以“获取-释放”语义是理解多线程编程中，同步和部分排序的关键。没有这些同步点，就不可能有(定义良好的)线程、任务或条件变量。

上一节中，介绍了原子操作的默认行为——顺序一致性(为每个原子操作指定内存顺序)。如果没有指定内存顺序，则应用保持顺序一致性，这就意味着`std::memory_order_seq_cst`将默认应用于每个原子操作上。

下面两端代码是等价的：

```c++
x.store(1);
res = x.load();
```

```c++
x.store(1, std::memory_order_seq_cst);
res = x.load(std::memory_order_seq_cst);
```

简单起见，本书使用第一种形式。现在，是深入了解C++内存模型原子性的时候了。就从`std::atomic_flag`开始吧。

## 原子标志

`std::atomic_flag`是原子布尔类型。可以对其进行状态的设置和清除。为了简化说明，我将`clear`状态称为`false`，将`set`状态称为`true`。它的`clear`方法可将其值设置为`false`。使用`test_and_set`方法，可以将值设置回`true`，并返回先前的值。没有方法获取当前值。使用`std::atomic_flag`时，必须使用常量`ATOMIC_FLAG_INIT`将其初始化为`false`。

> 注意：
>
> ATOMIC_FLAG_INIT
>
> `std::atomic_flag` 标示需要进行初始化，可以是这样`std::atomic_flag flag = ATOMIC_FLAG_INIT`。不过，不能这样初始化`std::atomic_flag flag(ATOMIC_FLAG_INIT) `。

`std::atomic_flag`有两个突出的特性：

* 唯一的无锁原子类型。程序是系统级别进程的话，那么执行的非阻塞算法就是无锁的。
* 更高级别的线程构建块。

除了`std::atomic_flag`之外，C++标准中的原子内部都会使用互斥锁。这些原子类型有一个`is_lock_free`成员函数，可用来检查原子内部是否使用了互斥锁。在时下流行的微处理器架构上，能得到是“使用了互斥锁”的结果。如果想要无锁编程，那么就要使用该成员函数进行检查，确定是否使用了锁。

> 贴士：
>
> `std::is_always_lock_free`
>
> 可以使用`obj.is_lock_free()`，在运行时检查原子类型的实例`obj`是否无锁。在C++17中，可以通过`constexpr`(常量)[`atomic<type>::is_always_lock_free`](https://zh.cppreference.com/w/cpp/atomic/atomic/is_always_lock_free)，在编译时对每个原子类型进行检查，支持该操作的所有硬件实现都无锁时，此检查才返回true。

`std::atomic_flag`的接口非常强大，能够构建自旋锁。自旋锁可以像使用互斥锁一样保护临界区。

> 贴士：
>
> 自旋锁
>
> 自旋锁与互斥锁不同，它并不再等待获取锁。而是，通过频繁地请求锁来获取访问临界区的权利。不过，这会将上下文频繁切换(从用户空间到内核空间)，虽然充分使用了CPU，但也浪费了非常多的时钟周期。线程短时间阻塞时，自旋锁非常有效。通常，会将自旋锁和互斥锁组合着使用。首先，在有限的时间内使用自旋锁，如果不成功，则将线程置于等待(休眠)状态。
>
> 自旋锁不应该在单处理器系统上使用。否则，自旋锁仅是浪费资源，减慢程序处理的速度(最好的情况)，或出现死锁(最坏的情况)。

下面的示例展示了，使用`std::atomic_flag`实现自旋锁

**`std::atomic_flag`实现的自旋锁**

```c++
// spinLock.cpp

#include <atomic>
#include <thread>

class Spinlock{
  std::atomic_flag flag = ATOMIC_FLAG_INIT;
public:
  void lock(){
    while(flag.test_and_set());
  }
  
  void unlock(){
    flag.clear();
  }
};

Spinlock spin;

void workOnResource(){
  spin.lock();
  // shared resource
  spin.unlock();
}

int main(){
  std::thread t(workOnResource);
  std::thread t2(workOnResource);
  
  t.join();
  t2.join();
}
```

线程t和t2(第31行和第32行)在争夺临界区的访问权。简单起见，第24行只有一条注释。自旋锁是如何工作的呢？自旋锁也有上锁和解锁。

当线程t执行函数`workOnResource`时，可能会发生以下情况。

1.  因为锁成功获取，所以线程`t`获取锁。若第11行的标志初始值为false，则锁调用成功。这种情况下，线程`t`的原子操作将其设置为true。所以，当`t`线程获取锁后，true将会让while陷入不停的循环，使得线程`t2`陷入了激烈的竞争当中。线程`t2`不能将标志设置为false，因此`t2`必须等待，直到线程`t1`执行`unlock`(解锁)并将标志设置为false(第14 - 16行)。
2.  线程`t`没有得到锁时，情况1中的`t2`一样，需要等待。

我们将注意力放在`std::atomic_flag`的`test_and_set`成员函数上。`test_and_set`函数包含两个操作：读和写。原子操作就是对这两种操作进行限制的。如果没有限制，我们将对共享资源同时进行读和写操作(第24行)。根据定义，这就是“数据竞争”，程序有产生未定义的行为。

将自旋锁的主动等待和互斥锁的被动等待做一下比较，应该会非常有趣。

### 自旋锁 vs. 互斥锁

如果函数`workOnResource`在第24行停顿2秒，那CPU负载会发生怎样的变化?

```c++
// spinLockSleep.cpp

#include <atomic>
#include <thread>

class Spinlock{
  std::atomic_flag flag = ATOMIC_FLAG_INIT;
public:
  
  void lock(){
    while(flag.test_and_set());
  }
  
  void unlock(){
    flag.clear();
  }
  
};

Spinlock spin;

void workOnResource(){
  spin.lock();
  std::this_thread::sleep_for(std::chrono::milliseconds(2000));
  spin.unlock();
}

int main(){
  
  std::thread t(workOnResource);
  std::thread t2(workOnResource);
  
  t.join();
  t2.join();
  
}
```

如下图所示，每次四个核中的一个是跑满了的。

![](../../../images/detail/memory-model/5.png)

我的PC上有一个核的负载达到100%，每次不同的核心执行”忙等待“。

我现在用互斥锁来替换自旋锁。让我们看下会发生什么。

```c++
// mutex.cpp

#include <mutex>
#include <thread>

std::mutex mut;

void workOnResource(){
  mut.lock();
  std::this_thread::sleep_for(std::chrono::milliseconds(5000));
  mut.unlock();
}

int main(){
  
  std::thread t(workOnResource);
  std::thread t2(workOnResource);
  
  t.join();
  t2.join();
}
```

虽然执行了好几次，但是并没有观察到任何一个核上有显著的负载。

这样就能看出二者间的区别了吧。

![](../../../images/detail/memory-model/6.png)

接下来，让我们了解下高级的`std::atomic`模板。

##  `std::atomic`模板

`std::atomic`的有各种各样的变体。

直接使用模板类：`std::atomic<bool>`和`std::atomic<user-defined type>`。

部分特化可用于指针类：`std::atomic<t*>`。

完全特化只能用于整型：`std::atomic<integral type>`。

The atomic booleans and atomic user-defined types support the same interface. The atomic pointer extends the interface of the atomic booleans and atomic integral types. The same applies to the atomic integral types: they extend the interface of the atomic pointers.

The downside of the various variations of std::atomic is that you do not have the guarantee that they are lock-free.

std::atomic<bool>

Let’s start with bool: std::atomic<bool> uses the primary template.

std::atomic<bool> has a lot more to offer than std::atomic_flag . It can explicitly be set to true or false.

> 注意：
>
> atomic is not volatile
>
> What does the keyword volatile in C# and Java have in common with the keyword volatile in C++? Nothing! That is the difference between volatile and std::atomic 
>
> * volatile: is for special objects, on which optimised read or write operations are not allowed
> * std::atomic: defines atomic variables, which are meant for a thread-safe reading and writing
>
> The confusion starts exactly here. The keyword volatile in Java and C# has the meaning of std::atomic in C++. Alternatively, volatile has no multithreading semantic in C++.
>
> volatile is typically used in embedded programming to denote objects which can change independently of the regular program flow. One example is an object which represents an external device (memory-mapped I/O). Because these objects can change independently of the regular program flow and their value is directly written into main memory, no optimised storing in caches takes place.

This is already sufficient to synchronise two threads, so I can implement a kind of a condition variable with a std::atomic<bool> 

Therefore, let’s first use a condition variable.

Usage of a condition variable

```c++

```

