# Fences

C++ support two kind of fences: a std::atomic_thread_fence and a std::atomic_signal_fence .

* std::atomic_thread_fence : synchronises memory accesses between threads.
* std::atomic_signal_fence : synchronises between a signal handler and code running on the same thread.

**std::atomic_thread_fence**

A std::atomic_thread_fence prevents specific operations from crossing a fence.

std::atomic_thread_fence needs no atomic variable. They are frequently just referred to as fences or memory barriers. You quickly get an idea what a std::atomic_thread_fence is all about.

## Fences as Memory Barriers

What does that mean? Specific operations cannot cross a memory barrier. What kind of operations? From a bird’s-eye view we have two kinds of operations: read and write or load and store operations. The expression if(resultRead) return result is a load, followed by a store operation.

There are four different ways to combine load and store operations:

* LoadLoad: A load followed by a load.
* LoadStore: A load followed by a store.
* StoreLoad: A store followed by a load.
* StoreStore: A store followed by a store.

Of course, there are more complicated operations consisting of multiple load and stores ( count++ ), and these operations fall into my general classification.

What about memory barriers? If you place memory barriers between two operations like LoadLoad, LoadStore, StoreLoad or StoreStore, you have the guarantee that specific LoadLoad, LoadStore, StoreLoad or StoreStore operations are not be reordered. The risk of reordering is always present if non-atomics or atomic operations with relaxed semantic are used.

## The Three Fences

Typically, three kinds of fences are used. They are called full fence, acquire fence and release fence. As a reminder, acquire is a load, and release is a store operation. What happens if I place one of the three memory barriers between the four combinations of load and store operations?

* Full fence: A full fence std::atomic_thread_fence() between two arbitrary operations prevents the reordering of these operations, but that guarantee does not hold for StoreLoad operations. They can be reordered.
*  Acquire fence: An acquire fence std::atomic_thread_fence(std::memory_order_acquire) prevents a read operation before an acquire fence from being reordered with a read or write operation after the acquire fence.
* Releasefence: A release fence std::atomic_thread_fence(std::memory_order_release) prevents a write operation after a relase fence from being reorderd with a read or write operation before a release fence.

A lot of energy goes into getting the definitions of the acquire and release fence and their consequences for lock-free programming right. Especially challenging to understand are the subtle differences between the acquire-release semantic of atomic operations. Before I get to that point, I illustrate the definitions with graphics.

Which kind of operations can cross a memory barrier? Have a look at the following three graphics. If the arrow is crossed with a red bar, the fence prevents this type of operation.

**Full fence**

![](../../../images/detail/memory-model/22.png)

Of course, instead of writing std::atomic_thread_fence() you can explicitly write std::atomic_thread_fence(std::memory_order_seq_cst) . Sequential consistency is applied to fences by default. If you use sequential consistency for a full fence, the std::atomic_thread_fence follows a global order.

**Acquire fence**

![](../../../images/detail/memory-model/23.png)

**Release fence**

![](../../../images/detail/memory-model/24.png)

The three memory barriers can be depicted even more concisely.

**All Fences at a Glance**

![](../../../images/detail/memory-model/25.png)

Acquire and release fences guarantee similar synchronisation and ordering constraints as atomics with acquire-release semantic.

## Acquire-Release Fences

The most apparent difference between acquire and release fences and atomics with acquire-release semantics is that fences need no atomics. There is also a more subtle difference; the acquire and release fences are more heavyweight than the corresponding atomics.

### Atomic Operations versus Fences

For the sake of simplicity, I now refer to acquire operations when I use fences or atomic operations with acquire semantics. The same holds for release operations.

The main idea of an acquire and a release operation is that it establishes synchronisation and ordering constraints between threads. These synchronisation and ordering constraints also hold for
atomic operations with relaxed semantic or non-atomic operations. Note that acquire and release operations come in pairs. Besides, operations on atomic variables with acquire-release semantic must act on the same atomic variable. Having said that I now look at these operations in isolation.

Let’s start with the acquire operation.

### Acquire Operation

A load (read) operation on an atomic variable with the memory-ordering set to std::memory_order_acquire is an acquire operation.

![](../../../images/detail/memory-model/26.png)

std::atomic_thread_fence with the memory order set to std::memory_order_acquire imposes stricter constraints on memory access reordering:

![](../../../images/detail/memory-model/27.png)

This comparison emphasises two points:

1. A fence with acquire semantic establishes stronger ordering constraints. Although the acquire operation on an atomic and on a fence require that no read or write operation can be moved before the acquire operation, there is an additional guarantee with the acquire fence. No read operation can be moved after the acquire fence.
2. The relaxed semantic is sufficient for the reading of the atomic variable var . Thanks to std::atomc_thread_fence(std::memory_order_acquire) , this operation cannot be moved after the acquire fence.

Similar observations can be made for the release fence.

### Release Operation

The store (write) operation on an atomic variable with the memory-ordering set to std::memory_order_release is a release operation.

![](../../../images/detail/memory-model/28.png)

Also, the release fence.

![](../../../images/detail/memory-model/29.png)

In addition to the constraints imposed by the release operation on an atomic variable var ,the release fence guarantees two properties:

1. Store operations can’t be moved before the fence.
2. It’s sufficient for the variable var to have relaxed semantic.

However now, it’s time to go one step further and build a program that uses fences.

## Synchronisation with Atomic Variables or Fences

As a starting point, I’ve implemented a typical consumer-producer workflow with the acquire-release semantic. Initially, I use atomics and then switch to fences.

### Atomic Operations

Let’s start with atomics because most of us are comfortable with them.

Acquire-release ordering with atomics

```c++

```

This program should be quite familiar to you. It is the classic example that I used in the subsection about std::memory_order_consume . The graphics emphasise exactly that the consumer thread t2 sees all values from the producer thread t1.

![](../../../images/detail/memory-model/30.png)

The program is well-defined because the happens-before relation is transitive. I only have to combine the three happens-before relations:

1. Lines 15 - 17 happens-before line 18 ptr.store(p,  std::memory_order_release) .
2. Line 23 while(!(p2= ptrl.load(std::memory_order_acquire))) happens-before the lines 24-26.
3. Line 18 synchronizes-with line 23. ⇒ Line 18 inter-thread happens-before line 23.

However, the story becomes more interesting. Now I come to fences. They are almost completely ignored in the literature on the C++ memory model.

### Fences

It’s quite straightforward to port the program to use fences.

Acquire-release ordering with fences

```c++

```

The first step was to add fences with release and acquire semantic (lines 18 and 25). Next, I changed the atomic operations with acquire or release semantic to relaxed semantic(lines 19 and 24 ).That was straightforward. Of course, I can only replace an acquire or release operation with the corresponding fence. The key point is that the release fence establishes a synchronizes-with relation with the acquire fence and therefore an inter-thread happens-before relation.

Here is the output of the program.

![](../../../images/detail/memory-model/31.png)

For the more visual reader, here’s the entire relation graphically.

![](../../../images/detail/memory-model/32.png)

The key question is: why do the operations after the acquire fence see the effects of the operations before the release fence?This is interesting because data is a non-atomic variable and atoData.store is used with relaxed semantic. This would suggest they can be reordered; however, thanks to the std::atomic_thread_fence(std::memory_order_release) as a release operation in combination with the std::atomic_thread_fence(std::memory_order_acquire) , neither can be reordered.

For clarity, the whole reasoning in a more concise form.

1.  The acquire and release fences prevent the reordering of the atomic and non-atomic operations across the fences.
2. The consumer thread t2 is waiting in the while (!(p2= ptr.load(std::memory_order_relaxed))) loop, until the pointer ptr.store(p,std::memory_order_relaxed) is set in the producer thread t1.
3.  The release fence synchronizes-with the acquire fence.
4.  In the end, all effects of relaxed or non-atomic operations that happen-before the release fence are visible after the acquire fence.

> 知识点
>
> **Synchronisation between the release fence and the
> acquire fence**
>
> The words from the [N4659: Working Draft, Standard for Programming Language C++](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4659.pdf) are quite difficult to get: “A release fence A synchronizes with an acquire fence B if there exist atomic operations X and Y, both operating on some atomic object M, such that A is sequenced before X, X modifies M, Y is sequenced before B, and Y reads the value written by X or a value written by any side effect in the hypothetical release sequence X would head if it were a release operation.”
>
> Let me explain the last sentence with the help of the program acquireReleaseFence.cpp
>
> * atomic_thread_fence(memory_order_release) (line 18) is the release fence A
> * atomic_thread_fence(memory_order_acquire) (line 25) is the acquire fence B
> * ptr (line 10) is the atomic object M
> * ptr.store(p, memory_order_relaxed) (line 19) is the atomic store X
> * while (!(p2 = ptr.load(memory_order_relaxed))) (line 24) is the atomic load Y

You can even mix the acquire and release operations on an atomic in the program acquireRelease.cpp with the acquire and release fence in the program acquireReleaseFence.cpp without affecting the synchronize-with relation.

#### std::atomic_signal_fence

std::atomic_signal_fence establishes memory synchronisation ordering of non-atomic and relaxed atomic accesses between a thread and a signal handler executed on the same thread. The following program shows the usage of a std::atomic_signal_fence 

Synchronisation with a signal handler

```c++

```

First, I set in line 19 the signal handler handler for the particular signal SIGTERM . SIGTERM is a termination request for the program. Both std::atomic_signal_handler establish an acquire-release fence between the release operation std::atomic_signal_fence(std::memory_order_release) (line 22) and the acquire operation std::atomic_signal_fence(std::memory_order_acquire) (line 12). This means in particular that release operations can not be reordered across the release fence (line 22) and that acquire operations can not be reordered across the acquire fence (line 11). Consequently, the assertion in line 13 assert(b.load(std::memory_order_relaxed)) never fires because if a.store(true, std::memory_order_relaxed) (line 23) happened, b.store(true, std::memory_order_relaxed) (line 21) must have happened before.

