# 栅栏

C++支持两种类型的栅栏类型：`std::atomic_thread_fence`和`std::atomic_signal_fence`。

* `std::atomic_thread_fence` : 同步线程间的内存访问。
* `std::atomic_signal_fence` : 线程内处理信号和代码之间的同步。

**`std::atomic_thread_fence`**

`std::atomic_thread_fence`可以阻止特定的操作翻过栅栏。

`std::atomic_thread_fence`不需要原子变量，通常称为栅栏或内存屏障。那就先来了解一下`std::atomic_thread_fence`。

## 栅栏当做内存屏障

这个小节的标题什么意思呢？特定的操作不能翻过内存屏障。那什么样的操作属于“特殊操作”呢？我们现在有两种操作：读写操作或加载/存储操作。` if(resultRead) return result `就是一个加载操作后跟一个存储操作。

有四种不同的方式来组合加载和存储操作：

* 加载-加载：一个加载操作后跟一个加载操作。
* 加载-存储：一个加载操作后跟一个存储操作。
* 存储-加载：一个存储操作后跟一个加载操作。
* 存储-存储：一个存储操作后跟一个存储操作。

当然，还有由多个加载和存储(`count++`)组成的更复杂的操作，这些操作都可由以上四个操作组成。

那么内存屏障呢？如果在加载-加载、加载-存储、存储-加载或存储-存储等操作之间设置内存屏障，则可以保证不会对特定的操作进行重新排序。如果使用非原子或具有自由语义的原子操作，则存在重新排序的风险。

## 三种栅栏类型

通常，栅栏有三种，分别是：全栅(full fence)、获取栅栏(acquire fence)和释放栅栏(release fence)。提醒一下，获取是一个加载操作， 释放是一个存储操作。如果在加载和存储操作的四种组合之间，放一个内存屏障中会发生什么情况呢?

* 全栅: 任意两个操作之间使用完整的栅栏`std::atomic_thread_fence()`，可以避免这些操作的重新排序。不过，对于存储-加载操作来说，这就不能保证了，它们可能会被重新排序。
*  获取栅栏: `std::atomic_thread_fence(std::memory_order_acquire)`避免在获取栅栏之前的读操作，被获取栅栏之后的读或写操作重新排序。
* 释放栅栏: `std::atomic_thread_fence(std::memory_order_release)`避免释放栅栏之后的写操作，在释放栅栏之前通过读或写操作重新排序。

为了获得和释放栅栏的定义，以及它们对无锁编程的影响，我们花费了大量的精力对其进行整理。特别难以理解的是，这种栅栏与原子操作获取-释放语义之间的差别。先用图来说明一些上面的定义。

哪种操作可以翻过内存屏障？先瞧瞧下面的三张图。如果箭头与红色横杠交叉，意味着栅栏会阻止这种操作。

**全栅**

![](../../../images/detail/memory-model/22.png)

当然，可以显式地调用`std::atomic_thread_fence(std::memory_order_seq_cst)`，而不是`std::atomic_thread_fence()`。默认情况下，栅栏使用内存序为顺序一致性。如果对全栏使用顺序一致性，那么`std::atomic_thread_fence`也将遵循全局序。

**获取栅栏**

![](../../../images/detail/memory-model/23.png)

**释放栅栏**

![](../../../images/detail/memory-model/24.png)

三种内存屏障可以描述得更简单。

**所有栅栏一览图**

![](../../../images/detail/memory-model/25.png)

获取和释放栅栏，与原子类的获取-释放语义有着相似的同步方式和排序约束。

## 获取-释放栅栏

The most apparent difference between acquire and release fences and atomics with acquire-release semantics is that fences need no atomics. There is also a more subtle difference; the acquire and release fences are more heavyweight than the corresponding atomics.

### 原子操作 Vs. 栅栏

For the sake of simplicity, I now refer to acquire operations when I use fences or atomic operations with acquire semantics. The same holds for release operations.

The main idea of an acquire and a release operation is that it establishes synchronisation and ordering constraints between threads. These synchronisation and ordering constraints also hold for
atomic operations with relaxed semantic or non-atomic operations. Note that acquire and release operations come in pairs. Besides, operations on atomic variables with acquire-release semantic must act on the same atomic variable. Having said that I now look at these operations in isolation.

Let’s start with the acquire operation.

### 获取操作

A load (read) operation on an atomic variable with the memory-ordering set to std::memory_order_acquire is an acquire operation.

![](../../../images/detail/memory-model/26.png)

std::atomic_thread_fence with the memory order set to std::memory_order_acquire imposes stricter constraints on memory access reordering:

![](../../../images/detail/memory-model/27.png)

This comparison emphasises two points:

1. A fence with acquire semantic establishes stronger ordering constraints. Although the acquire operation on an atomic and on a fence require that no read or write operation can be moved before the acquire operation, there is an additional guarantee with the acquire fence. No read operation can be moved after the acquire fence.
2. The relaxed semantic is sufficient for the reading of the atomic variable var . Thanks to std::atomc_thread_fence(std::memory_order_acquire) , this operation cannot be moved after the acquire fence.

Similar observations can be made for the release fence.

### 释放操作

The store (write) operation on an atomic variable with the memory-ordering set to std::memory_order_release is a release operation.

![](../../../images/detail/memory-model/28.png)

Also, the release fence.

![](../../../images/detail/memory-model/29.png)

In addition to the constraints imposed by the release operation on an atomic variable var ,the release fence guarantees two properties:

1. Store operations can’t be moved before the fence.
2. It’s sufficient for the variable var to have relaxed semantic.

However now, it’s time to go one step further and build a program that uses fences.

## Synchronisation with Atomic Variables or Fences

As a starting point, I’ve implemented a typical consumer-producer workflow with the acquire-release semantic. Initially, I use atomics and then switch to fences.

### Atomic Operations

Let’s start with atomics because most of us are comfortable with them.

Acquire-release ordering with atomics

```c++

```

This program should be quite familiar to you. It is the classic example that I used in the subsection about std::memory_order_consume . The graphics emphasise exactly that the consumer thread t2 sees all values from the producer thread t1.

![](../../../images/detail/memory-model/30.png)

The program is well-defined because the happens-before relation is transitive. I only have to combine the three happens-before relations:

1. Lines 15 - 17 happens-before line 18 ptr.store(p,  std::memory_order_release) .
2. Line 23 while(!(p2= ptrl.load(std::memory_order_acquire))) happens-before the lines 24-26.
3. Line 18 synchronizes-with line 23. ⇒ Line 18 inter-thread happens-before line 23.

However, the story becomes more interesting. Now I come to fences. They are almost completely ignored in the literature on the C++ memory model.

### Fences

It’s quite straightforward to port the program to use fences.

Acquire-release ordering with fences

```c++

```

The first step was to add fences with release and acquire semantic (lines 18 and 25). Next, I changed the atomic operations with acquire or release semantic to relaxed semantic(lines 19 and 24 ).That was straightforward. Of course, I can only replace an acquire or release operation with the corresponding fence. The key point is that the release fence establishes a synchronizes-with relation with the acquire fence and therefore an inter-thread happens-before relation.

Here is the output of the program.

![](../../../images/detail/memory-model/31.png)

For the more visual reader, here’s the entire relation graphically.

![](../../../images/detail/memory-model/32.png)

The key question is: why do the operations after the acquire fence see the effects of the operations before the release fence?This is interesting because data is a non-atomic variable and atoData.store is used with relaxed semantic. This would suggest they can be reordered; however, thanks to the std::atomic_thread_fence(std::memory_order_release) as a release operation in combination with the std::atomic_thread_fence(std::memory_order_acquire) , neither can be reordered.

For clarity, the whole reasoning in a more concise form.

1.  The acquire and release fences prevent the reordering of the atomic and non-atomic operations across the fences.
2. The consumer thread t2 is waiting in the while (!(p2= ptr.load(std::memory_order_relaxed))) loop, until the pointer ptr.store(p,std::memory_order_relaxed) is set in the producer thread t1.
3.  The release fence synchronizes-with the acquire fence.
4.  In the end, all effects of relaxed or non-atomic operations that happen-before the release fence are visible after the acquire fence.

> 知识点
>
> **Synchronisation between the release fence and the
> acquire fence**
>
> The words from the [N4659: Working Draft, Standard for Programming Language C++](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4659.pdf) are quite difficult to get: “A release fence A synchronizes with an acquire fence B if there exist atomic operations X and Y, both operating on some atomic object M, such that A is sequenced before X, X modifies M, Y is sequenced before B, and Y reads the value written by X or a value written by any side effect in the hypothetical release sequence X would head if it were a release operation.”
>
> Let me explain the last sentence with the help of the program acquireReleaseFence.cpp
>
> * atomic_thread_fence(memory_order_release) (line 18) is the release fence A
> * atomic_thread_fence(memory_order_acquire) (line 25) is the acquire fence B
> * ptr (line 10) is the atomic object M
> * ptr.store(p, memory_order_relaxed) (line 19) is the atomic store X
> * while (!(p2 = ptr.load(memory_order_relaxed))) (line 24) is the atomic load Y

You can even mix the acquire and release operations on an atomic in the program acquireRelease.cpp with the acquire and release fence in the program acquireReleaseFence.cpp without affecting the synchronize-with relation.

#### std::atomic_signal_fence

std::atomic_signal_fence establishes memory synchronisation ordering of non-atomic and relaxed atomic accesses between a thread and a signal handler executed on the same thread. The following program shows the usage of a std::atomic_signal_fence 

Synchronisation with a signal handler

```c++

```

First, I set in line 19 the signal handler handler for the particular signal SIGTERM . SIGTERM is a termination request for the program. Both std::atomic_signal_handler establish an acquire-release fence between the release operation std::atomic_signal_fence(std::memory_order_release) (line 22) and the acquire operation std::atomic_signal_fence(std::memory_order_acquire) (line 12). This means in particular that release operations can not be reordered across the release fence (line 22) and that acquire operations can not be reordered across the acquire fence (line 11). Consequently, the assertion in line 13 assert(b.load(std::memory_order_relaxed)) never fires because if a.store(true, std::memory_order_relaxed) (line 23) happened, b.store(true, std::memory_order_relaxed) (line 21) must have happened before.

